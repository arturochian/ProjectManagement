{"name":"Project Management","tagline":"Project management project","body":"Introduction\r\n------------\r\n\r\nThis is a project management project. While current projects are shown\r\nin the chart below, the aim of this project is the development of\r\nconvenient **R**-related project management tools.\r\n\r\n### Motivation\r\n\r\nI am working on these tools to enhance my own workflow across multiple\r\n**R** projects.\r\n\r\n### Details\r\n\r\n**R** code for the project will be compiled into an **R** package,\r\n`projman` for easy use. This is a personal package and will not be\r\navailable anywhere but my github repository, but you are welcome to\r\nexplore the package and functions. It is unlikely that you would manage\r\nyour **R** projects in the same manner that I do, but if you do, or just\r\nwant some ideas, feel free to explore.\r\n\r\n#### Capabilities\r\n\r\n`projman` can create a new project. This essentially generates a\r\nspecific directory structure which I use often to manage project files.\r\nFor an existing project, once **R** scripts have been created, `projman`\r\ncan generate template `.Rmd` files for each. For existing `.Rmd` files,\r\n`projman` can conveniently append these **R** Markdown files with a list\r\nof any new `knitr` code chunk names in project **R** scripts being\r\ndeveloped which have not yet been included in the respective `.Rmd`\r\nfiles.\r\n\r\n#### Limitations\r\n\r\nWhile `projman` assists with project documentation, this mainly takes\r\nthe form of file generation and appending. Documentation is unique to\r\nevery project of course. Every script is different. The most that is\r\npossible is to auto-fill commonly used code chunk names and metadata.\r\nEach document must be written individually by the author, but when a\r\nproject has many **R** scripts requiring documentation, it is nice to\r\nnot have to create all the corresponding `.Rmd` files by hand and copy\r\nand paste generic contents.\r\n\r\nThe project management code is not yet in package form. Many additional\r\nfeatures are yet to be incorporated. Generic code relating to the\r\nfurther processing of `.Rmd` files into various other output files via\r\n`rmarkdown` and `knitr` will fold into this project, but this has not\r\nbeen done yet.\r\n\r\nRelated items\r\n-------------\r\n\r\nCurrently there is only this unpackaged **R** script and accompanying\r\ncode for a projects hierarchy diagram. No additional related items are\r\navailable at this time, but those referenced above will eventually be\r\nincluded.\r\n\r\n### Files and Data\r\n\r\nThis project does not use any data. `sankey.R` is used to produce of\r\nproject hierarchy diagram of my current projects.\r\n\r\n### Code flow\r\n\r\nThe Sankey diagram has become part of project management. Each project\r\nhas its own, detailing the relationships among **R** code and data\r\nrelevent to the project, and in some cases, how they relate to code and\r\ndata files which are more general and span multiple projects. This\r\ndiagram be available for this project once more project code has been\r\ndeveloped.\r\n\r\n### Current projects\r\n\r\nHere is a project hierarchy diagram showing the relationships among all\r\nmy current projects.\r\n\r\n<iframe srcdoc=\" &lt;!doctype HTML&gt;\r\n&lt;meta charset = 'utf-8'&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;link rel='stylesheet' href='http://timelyportfolio.github.io/rCharts_d3_sankey/css/sankey.css'&gt;\r\n    \r\n    &lt;script src='http://d3js.org/d3.v3.min.js' type='text/javascript'&gt;&lt;/script&gt;\r\n    &lt;script src='http://timelyportfolio.github.io/rCharts_d3_sankey/js/sankey.js' type='text/javascript'&gt;&lt;/script&gt;\r\n    \r\n    &lt;style&gt;\r\n    .rChart {\r\n      display: block;\r\n      margin-left: auto; \r\n      margin-right: auto;\r\n      width: 900px;\r\n      height: 600px;\r\n    }  \r\n    &lt;/style&gt;\r\n    \r\n  &lt;/head&gt;\r\n  &lt;body &gt;\r\n    \r\n    &lt;div id = 'chart162056bf42e0' class = 'rChart d3_sankey'&gt;&lt;/div&gt;    \r\n    ï»¿&lt;!--Attribution:\r\nMike Bostock https://github.com/d3/d3-plugins/tree/master/sankey\r\nMike Bostock http://bost.ocks.org/mike/sankey/\r\n--&gt;\r\n\r\n&lt;script&gt;\r\n(function(){\r\nvar params = {\r\n &quot;dom&quot;: &quot;chart162056bf42e0&quot;,\r\n&quot;width&quot;:    900,\r\n&quot;height&quot;:    600,\r\n&quot;data&quot;: {\r\n &quot;source&quot;: [ &quot;Collaborators&quot;, &quot;Collaborators&quot;, &quot;Collaborators&quot;, &quot;Collaborators&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Matt&quot;, &quot;Paul&quot;, &quot;Alec&quot;, &quot;Angie&quot;, &quot;Angie&quot;, &quot;Bob&quot;, &quot;Angie&quot;, &quot;Bob&quot;, &quot;Alfresco Outputs&quot;, &quot;Alfresco Outputs&quot;, &quot;Alfresco Outputs&quot;, &quot;SNAP Data QA/QC&quot;, &quot;SNAP Data QA/QC&quot;, &quot;SNAP Data QA/QC&quot;, &quot;SNAP Data QA/QC&quot;, &quot;Spatial Lightning Analysis&quot;, &quot;Spatial Lightning Analysis&quot;, &quot;Spatial Lightning Analysis&quot;, &quot;Sea Ice Edge Maps and Spinoff Projects&quot;, &quot;Sea Ice Edge Maps and Spinoff Projects&quot;, &quot;Training/Supervision&quot;, &quot;Training/Supervision&quot;, &quot;Randscape Development&quot;, &quot;Randscape Development&quot;, &quot;Effective Spatial Scale Analysis&quot;, &quot;Effective Spatial Scale Analysis&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;Alfresco Noatak&quot;, &quot;Alfresco Statewide&quot;, &quot;Data Extraction and Uncertainty Analysis&quot;, &quot;Data Extraction and Uncertainty Analysis&quot;, &quot;Data Extraction and Uncertainty Analysis&quot;, &quot;Data Extraction and Uncertainty Analysis&quot; ],\r\n&quot;target&quot;: [ &quot;Paul&quot;, &quot;Alec&quot;, &quot;Angie&quot;, &quot;Bob&quot;, &quot;CMIP3/CMIP5 GCM Comparisons&quot;, &quot;Effective Spatial Scale Analysis&quot;, &quot;Randscape Development&quot;, &quot;Alfresco Outputs&quot;, &quot;SNAP Data QA/QC&quot;, &quot;Training/Supervision&quot;, &quot;R Shiny Apps General Maintenance&quot;, &quot;New App Development&quot;, &quot;SNAP Tech Blog&quot;, &quot;Continuing Education&quot;, &quot;FRP/FRI Scale-Conditional Alfresco Maps&quot;, &quot;Moose Project&quot;, &quot;Alfresco Noatak&quot;, &quot;Alfresco Statewide&quot;, &quot;Spatial Lightning Analysis&quot;, &quot;Data Extraction and Uncertainty Analysis&quot;, &quot;Growing Season&quot;, &quot;Mussel Project&quot;, &quot;Land Carbon&quot;, &quot;Alfresco Noatak&quot;, &quot;Alfresco Statewide&quot;, &quot;Spatial Lightning Analysis&quot;, &quot;Data Extraction and Uncertainty Analysis&quot;, &quot;Growing Season&quot;, &quot;Mussel Project&quot;, &quot;Land Carbon&quot;, &quot;Alfresco CRU/GCM Experimental Design&quot;, &quot;Bird Project&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;Sea Ice Edge Maps and Spinoff Projects&quot;, &quot;Shiny App Server Migration&quot;, &quot;Alfresco CRU/GCM Experimental Design&quot;, &quot;Alfresco CRU/GCM Experimental Design&quot;, &quot;Bird Project&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;Sea Ice Edge Maps and Spinoff Projects&quot;, &quot;Shiny App Server Migration&quot;, &quot;CMIP3/CMIP5 GCM Comparisons&quot;, &quot;Land Carbon&quot;, &quot;Bird Project&quot;, &quot;Alfresco Outputs&quot;, &quot;CMIP3/CMIP5 GCM Comparisons&quot;, &quot;Alfresco CRU/GCM Experimental Design&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;Alfresco Noatak&quot;, &quot;Alfresco Statewide&quot;, &quot;Randscape Development&quot;, &quot;Randscape Development&quot;, &quot;Alfresco Outputs&quot;, &quot;Bird Project&quot;, &quot;NWT/Comm. Charts DS&quot;, &quot;Alfresco Outputs&quot;, &quot;Effective Spatial Scale Analysis&quot;, &quot;Alfresco Outputs&quot;, &quot;FRP/FRI Scale-Conditional Alfresco Maps&quot;, &quot;CMIP3/CMIP5 GCM Comparisons&quot;, &quot;FRP/FRI Scale-Conditional Alfresco Maps&quot;, &quot;FRP/FRI Scale-Conditional Alfresco Maps&quot;, &quot;CMIP3/CMIP5 GCM Comparisons&quot;, &quot;Effective Spatial Scale Analysis&quot;, &quot;Randscape Development&quot;, &quot;Alfresco Outputs&quot; ],\r\n&quot;value&quot;: [      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1,      1 ] \r\n},\r\n&quot;nodeWidth&quot;:     15,\r\n&quot;nodePadding&quot;:     10,\r\n&quot;layout&quot;:     32,\r\n&quot;margin&quot;: {\r\n &quot;right&quot;:     20,\r\n&quot;left&quot;:     20,\r\n&quot;bottom&quot;:     20,\r\n&quot;top&quot;:     20 \r\n},\r\n&quot;title&quot;: &quot;Matt's Projects&quot;,\r\n&quot;id&quot;: &quot;chart162056bf42e0&quot; \r\n};\r\n\r\nparams.units ? units = &quot; &quot; + params.units : units = &quot;&quot;;\r\n\r\n//hard code these now but eventually make available\r\nvar formatNumber = d3.format(&quot;0,.0f&quot;),    // zero decimal places\r\n    format = function(d) { return formatNumber(d) + units; },\r\n    color = d3.scale.category20();\r\n\r\nif(params.labelFormat){\r\n  formatNumber = d3.format(&quot;.2%&quot;);\r\n}\r\n\r\nvar svg = d3.select('#' + params.id).append(&quot;svg&quot;)\r\n    .attr(&quot;width&quot;, params.width)\r\n    .attr(&quot;height&quot;, params.height);\r\n    \r\nvar sankey = d3.sankey()\r\n    .nodeWidth(params.nodeWidth)\r\n    .nodePadding(params.nodePadding)\r\n    .layout(params.layout)\r\n    .size([params.width,params.height]);\r\n    \r\nvar path = sankey.link();\r\n    \r\nvar data = params.data,\r\n    links = [],\r\n    nodes = [];\r\n    \r\n//get all source and target into nodes\r\n//will reduce to unique in the next step\r\n//also get links in object form\r\ndata.source.forEach(function (d, i) {\r\n    nodes.push({ &quot;name&quot;: data.source[i] });\r\n    nodes.push({ &quot;name&quot;: data.target[i] });\r\n    links.push({ &quot;source&quot;: data.source[i], &quot;target&quot;: data.target[i], &quot;value&quot;: +data.value[i] });\r\n}); \r\n\r\n//now get nodes based on links data\r\n//thanks Mike Bostock https://groups.google.com/d/msg/d3-js/pl297cFtIQk/Eso4q_eBu1IJ\r\n//this handy little function returns only the distinct / unique nodes\r\nnodes = d3.keys(d3.nest()\r\n                .key(function (d) { return d.name; })\r\n                .map(nodes));\r\n\r\n//it appears d3 with force layout wants a numeric source and target\r\n//so loop through each link replacing the text with its index from node\r\nlinks.forEach(function (d, i) {\r\n    links[i].source = nodes.indexOf(links[i].source);\r\n    links[i].target = nodes.indexOf(links[i].target);\r\n});\r\n\r\n//now loop through each nodes to make nodes an array of objects rather than an array of strings\r\nnodes.forEach(function (d, i) {\r\n    nodes[i] = { &quot;name&quot;: d };\r\n});\r\n\r\nsankey\r\n  .nodes(nodes)\r\n  .links(links)\r\n  .layout(params.layout);\r\n  \r\nvar link = svg.append(&quot;g&quot;).selectAll(&quot;.link&quot;)\r\n  .data(links)\r\n.enter().append(&quot;path&quot;)\r\n  .attr(&quot;class&quot;, &quot;link&quot;)\r\n  .attr(&quot;d&quot;, path)\r\n  .style(&quot;stroke-width&quot;, function (d) { return Math.max(1, d.dy); })\r\n  .sort(function (a, b) { return b.dy - a.dy; });\r\n\r\nlink.append(&quot;title&quot;)\r\n  .text(function (d) { return d.source.name + &quot; â†’ &quot; + d.target.name + &quot;\\n&quot; + format(d.value); });\r\n\r\nvar node = svg.append(&quot;g&quot;).selectAll(&quot;.node&quot;)\r\n  .data(nodes)\r\n.enter().append(&quot;g&quot;)\r\n  .attr(&quot;class&quot;, &quot;node&quot;)\r\n  .attr(&quot;transform&quot;, function (d) { return &quot;translate(&quot; + d.x + &quot;,&quot; + d.y + &quot;)&quot;; })\r\n.call(d3.behavior.drag()\r\n  .origin(function (d) { return d; })\r\n  .on(&quot;dragstart&quot;, function () { this.parentNode.appendChild(this); })\r\n  .on(&quot;drag&quot;, dragmove));\r\n\r\nnode.append(&quot;rect&quot;)\r\n  .attr(&quot;height&quot;, function (d) { return d.dy; })\r\n  .attr(&quot;width&quot;, sankey.nodeWidth())\r\n  .style(&quot;fill&quot;, function (d) { return d.color = color(d.name.replace(/ .*/, &quot;&quot;)); })\r\n  .style(&quot;stroke&quot;, function (d) { return d3.rgb(d.color).darker(2); })\r\n.append(&quot;title&quot;)\r\n  .text(function (d) { return d.name + &quot;\\n&quot; + format(d.value); });\r\n\r\nnode.append(&quot;text&quot;)\r\n  .attr(&quot;x&quot;, -6)\r\n  .attr(&quot;y&quot;, function (d) { return d.dy / 2; })\r\n  .attr(&quot;dy&quot;, &quot;.35em&quot;)\r\n  .attr(&quot;text-anchor&quot;, &quot;end&quot;)\r\n  .attr(&quot;transform&quot;, null)\r\n  .text(function (d) { return d.name; })\r\n.filter(function (d) { return d.x &lt; params.width / 2; })\r\n  .attr(&quot;x&quot;, 6 + sankey.nodeWidth())\r\n  .attr(&quot;text-anchor&quot;, &quot;start&quot;);\r\n\r\n// the function for moving the nodes\r\n  function dragmove(d) {\r\n    d3.select(this).attr(&quot;transform&quot;, \r\n        &quot;translate(&quot; + (\r\n                   d.x = Math.max(0, Math.min(params.width - d.dx, d3.event.x))\r\n                ) + &quot;,&quot; + (\r\n                   d.y = Math.max(0, Math.min(params.height - d.dy, d3.event.y))\r\n                ) + &quot;)&quot;);\r\n        sankey.relayout();\r\n        link.attr(&quot;d&quot;, path);\r\n  }\r\n})();\r\n&lt;/script&gt;\r\n    \r\n    \r\n    &lt;script&gt;\r\n      var cscale = d3.scale.category20b();\r\n    \r\n      // to be specific in case you have more than one chart\r\n      d3.selectAll('#chart162056bf42e0 svg path.link')\r\n        .style('stroke', function(d){\r\n          //here we will use the source color\r\n          //if you want target then sub target for source\r\n          //or if you want something other than gray\r\n          //supply a constant\r\n          //or use a categorical scale or gradient\r\n          //return d.source.color;\r\n          return cscale(d.source.name);\r\n        })\r\n       //note no changes were made to opacity\r\n       //to do uncomment below but will affect mouseover\r\n       //so will need to define mouseover and mouseout\r\n       //happy to show how to do this also\r\n       // .style('stroke-opacity', .7)\r\n      d3.selectAll('#chart162056bf42e0 svg .node rect')\r\n        .style('fill', function(d){\r\n          return cscale(d.name)\r\n        })\r\n        .style('stroke', 'none')\r\n    &lt;/script&gt;\r\n        \r\n  &lt;/body&gt;\r\n&lt;/html&gt; \" scrolling=\"no\" frameBorder=\"0\" seamless class=\"rChart  http://timelyportfolio.github.io/rCharts_d3_sankey/libraries/widgets/d3_sankey  \" id=\"iframe-chart162056bf42e0\">\r\n</iframe>\r\n<style>iframe.rChart{ width: 100%; height: 400px;}</style>\r\n<style>iframe.rChart{ width: 100%; height: 640px;}</style>\r\nR code\r\n------\r\n\r\n### Template objects\r\n\r\nCharacter string objects are defined which are used to fill templates\r\nwhen generating new files for a project. A tentative default path is\r\nalso included since this code relates to my own work.\r\n\r\n    # For package 'projman'\r\n\r\n    # data\r\n    rmd.header <- \"---\\ntitle: \\\"INSERT_TITLE_HERE\\\"\\nauthor: Matthew Leonawicz\\noutput:\\n  html_document:\\n    toc: true\\n    theme: united\\n    keep_md: true\\n  ioslides_presentation:\\n    widescreen: true\\n    keep_md: true\\n  pdf_document:\\n    toc: true\\n    highlight: zenburn\\n---\\n\"\r\n\r\n    rmd.knitr.setup <- \"\\n```{r knitr_setup, echo=FALSE}\\nopts_chunk$set(cache=FALSE, eval=FALSE, tidy=TRUE, messages=FALSE, warnings=FALSE)\\nread_chunk(\\\"\\\")\\n```\\n\"\r\n\r\n    rmd.template <- \"\\n\\n## Introduction\\nADD_TEXT_HERE\\n\\n### Motivation\\nADD_TEXT_HERE\\n\\n### Details\\nADD_TEXT_HERE\\n\\n#### Capabilities\\nADD_TEXT_HERE\\n\\n#### Limitations\\nADD_TEXT_HERE\\n\\n## Related items\\n\\n### Files and Data\\nADD_TEXT_HERE\\n\\n### Code flow\\nADD_TEXT_HERE\\n\\n```{r code_sankey, echo=F, eval=T}\\n```\\n\\n```{r code_sankey_embed, echo=F, eval=T, comment=NA, results=\\\"asis\\\", tidy=F}\\n```\\n\\n## R code\\n\\n### Setup\\nADD_TEXT_HERE: EXAMPLE\\nSetup consists of loading required **R** packages and additional files, preparing any command line arguments for use, and defining functions and other **R** objects.\\n\\n\"\r\n\r\n    # default path\r\n    matt.proj.path <- \"C:/github\"\r\n\r\n### Package functions\r\n\r\nFunctions are defined for creating new projects, generating `.Rmd` files\r\nfor project **R** scripts, and appending these **R** Markdown files with\r\nupdated information from the corresponding **R** scripts as their\r\ndevelopment continues. Additional functions will be incorporated later.\r\n\r\n#### newProject\r\n\r\n`newProject` creates a new named project directory structure at the\r\nspecified file path. If a directory with this project name already\r\nexists in this location on the file system, the function will abort.\r\nDefault project subdirectories are created unless a different vector of\r\nfolder names is explicitly passed to `newProject`. If one of the\r\nsubdirectories is `docs` then the default vector of subdirectories under\r\n`docs` is also created. This argument can also be set explicitly.\r\n\r\n    newProject <- function(name, path, dirs = c(\"code\", \"data\", \"docs\", \"plots\", \r\n        \"workspaces\"), docs.dirs = c(\"all\", \"diagrams\", \"ioslides\", \"md\", \"notebook\", \r\n        \"pdf\", \"Rmd\", \"timeline\", \"tufte\")) {\r\n        \r\n        stopifnot(is.character(name))\r\n        name <- file.path(path, name)\r\n        if (file.exists(name)) \r\n            stop(\"This project already exists.\")\r\n        dir.create(name, recursive = TRUE, showWarnings = FALSE)\r\n        if (!file.exists(name)) \r\n            stop(\"Directory appears invalid.\")\r\n        \r\n        path.dirs <- file.path(name, dirs)\r\n        sapply(path.dirs, dir.create, showWarnings = FALSE)\r\n        path.docs <- file.path(name, \"docs\", docs.dirs)\r\n        if (\"docs\" %in% dirs) \r\n            sapply(path.docs, dir.create, showWarnings = FALSE)\r\n        cat(\"Project created.\\n\")\r\n    }\r\n\r\n#### genRmd\r\n\r\n`genRmd` works on existing projects. It checks for existing **R**\r\nscripts. If not `.R` files exist in the project's `code` directory, the\r\nfunction will abort. Otherwise it will generate `.Rmd` template files\r\nfor each of the **R** scripts it finds. The `.Rmd` files are placed in\r\nthe `/docs/Rmd` directory. This function assumes this project directory\r\nexists.\r\n\r\n    genRmd <- function(path, replace = FALSE, ...) {\r\n        stopifnot(is.character(path))\r\n        files <- list.files(path, pattern = \".R$\", full = TRUE)\r\n        stopifnot(length(files) > 0)\r\n        rmd <- gsub(\".R\", \".Rmd\", basename(files))\r\n        rmd <- file.path(dirname(path), \"docs/Rmd\", rmd)\r\n        if (!replace) \r\n            rmd <- rmd[!sapply(rmd, file.exists)]\r\n        \r\n        sinkRmd <- function(x, ...) {\r\n            y1 <- list(...)$rmd.header\r\n            y2 <- list(...)$rmd.knitr.setup\r\n            y3 <- list(...)$rmd.template\r\n            if (is.null(y1)) \r\n                y1 <- rmd.header\r\n            if (is.null(y2)) \r\n                y2 <- rmd.knitr.setup\r\n            if (is.null(y3)) \r\n                y3 <- rmd.template\r\n            sink(x)\r\n            sapply(c(y1, y2, y3), function(y) if (is.character(y)) \r\n                cat(y))\r\n            sink()\r\n        }\r\n        \r\n        if (length(rmd)) {\r\n            sapply(rmd, sinkRmd, ...)\r\n            cat(\".Rmd files created for each .R file.\\n\")\r\n        } else {\r\n            cat(\"No new .Rmd files created.\\n\")\r\n        }\r\n    }\r\n\r\n#### chunkNames\r\n\r\n`chunkNames` can be used in two ways. It can return a list with length\r\nequal to the number of `.R` files, where each list element is a vector\r\nof **R** code chunk names found in each **R** script.\r\n\r\nAlternatively, with `append.new=TRUE`, this list has each vector matched\r\nelement-wise against chunk names found in existing `.Rmd` files. If no\r\n`.Rmd` files have yet been generated, the function will abort.\r\nOtherwise, for the `.Rmd` files which do exist (and this may correspond\r\nto a subset of the `.R` files), these `.Rmd` files are appended with a\r\nlist of code chunk names found in the current corresponding `.R` files\r\nwhich have not yet been integrated into the current state of the `.Rmd`\r\nfiles. This fascilitates updating of `.Rmd` documentation when it falls\r\nbehind scripts which have been updated.\r\n\r\n    chunkNames <- function(path, rChunkID = \"# @knitr\", rmdChunkID = \"```{r\", append.new = FALSE) {\r\n        files <- list.files(path, pattern = \".R$\", full = TRUE)\r\n        stopifnot(length(files) > 0)\r\n        l1 <- lapply(files, readLines)\r\n        l1 <- rapply(l1, function(x) x[substr(x, 1, nchar(rChunkID)) == rChunkID], \r\n            how = \"replace\")\r\n        l1 <- rapply(l1, function(x, p) gsub(paste0(p, \" \"), \"\", x), how = \"replace\", \r\n            p = rChunkID)\r\n        if (!append.new) \r\n            return(l1)\r\n        \r\n        appendRmd <- function(x, rmd.files, rChunks, rmdChunks, ID) {\r\n            r1 <- rmdChunks[[x]]\r\n            r2 <- rChunks[[x]]\r\n            r.new <- r2[!(r2 %in% r1)]\r\n            if (length(r.new)) {\r\n                r.new <- paste0(ID, \" \", r.new, \"}\\n```\\n\", collapse = \"\")  # Hard coded brace and backticks\r\n                sink(rmd.files[x], append = TRUE)\r\n                cat(\"\\nNEW_CODE_CHUNKS\\n\")\r\n                cat(r.new)\r\n                sink()\r\n                paste(basename(rmd.files[x]), \"appended with new chunk names from .R file\")\r\n            } else paste(\"No new chunk names appended to\", basename(rmd.files[x]))\r\n        }\r\n        \r\n        rmd <- gsub(\".R\", \".Rmd\", basename(files))\r\n        rmd <- file.path(dirname(path), \"docs/Rmd\", rmd)\r\n        rmd <- rmd[sapply(rmd, file.exists)]\r\n        stopifnot(length(rmd) > 0)  # Rmd files must exist\r\n        files.ind <- match(gsub(\".Rmd\", \"\", basename(rmd)), gsub(\".R\", \"\", basename(files)))  # Rmd exist for which R script\r\n        l2 <- lapply(rmd, readLines)\r\n        l2 <- rapply(l2, function(x) x[substr(x, 1, nchar(rmdChunkID)) == rmdChunkID], \r\n            how = \"replace\")\r\n        l2 <- rapply(l2, function(x, p) gsub(paste0(p, \" \"), \"\", x), how = \"replace\", \r\n            p = gsub(\"\\\\{\", \"\\\\\\\\{\", rmdChunkID))\r\n        l2 <- rapply(l2, function(x) gsub(\"}\", \"\", sapply(strsplit(x, \",\"), \"[[\", \r\n            1)), how = \"replace\")\r\n        sapply(1:length(rmd), appendRmd, rmd.files = rmd, rChunks = l1[files.ind], \r\n            rmdChunks = l2, ID = rmdChunkID)\r\n    }\r\n\r\nRegarding the creation and updating of `.Rmd` files, `projman` simply\r\nassumes that there will be one **R** Markdown file corresponding to one\r\n**R** script. This is not always the case for a given project, but\r\nagain, the purpose is to generate basic templates. Unnecessary files can\r\nalways be deleted later, or edits made such that one **R** Markdown file\r\nreads multiple **R** scripts, as is the case with the `.Rmd` file used\r\nto generate this document.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}